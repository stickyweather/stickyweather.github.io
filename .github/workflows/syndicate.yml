name: Syndicate Social Posts

on:
  push:
    branches:
      - master
    paths:
      - '_notes/**'  # Watch for new notes

jobs:
  syndicate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 2
      
      - name: Get new notes
        id: new_notes
        run: |
          NEW_FILES=$(git diff --name-only --diff-filter=A HEAD~1 HEAD | grep '^_notes/.*\.md$' || true)
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$NEW_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Setup Node.js
        if: steps.new_notes.outputs.files != ''
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Syndicate posts
        if: steps.new_notes.outputs.files != ''
        env:
          MASTODON_ACCESS_TOKEN: ${{ secrets.MASTODON_ACCESS_TOKEN }}
          MASTODON_INSTANCE: ${{ secrets.MASTODON_INSTANCE }}
          BLUESKY_HANDLE: ${{ secrets.BLUESKY_HANDLE }}
          BLUESKY_APP_PASSWORD: ${{ secrets.BLUESKY_APP_PASSWORD }}
          SITE_URL: ${{ secrets.SITE_URL }}
        run: |
          cat << 'SCRIPT_EOF' > syndicate.js
          const fs = require('fs');
          const https = require('https');
          const path = require('path');

          function parsePost(filepath) {
            const content = fs.readFileSync(filepath, 'utf8');
            const match = content.match(/^---\n([\s\S]+?)\n---\n([\s\S]*)$/);
            if (!match) return null;
            const frontmatter = {};
            match[1].split('\n').forEach(line => {
              const [key, ...valueParts] = line.split(':');
              if (key) frontmatter[key.trim()] = valueParts.join(':').trim().replace(/^["']|["']$/g, '');
            });
            return { frontmatter, content: match[2].trim(), filepath };
          }

          async function postToMastodon(text, postUrl) {
            const instance = process.env.MASTODON_INSTANCE;
            const token = process.env.MASTODON_ACCESS_TOKEN;
            const status = text + '\n\n' + postUrl;
            const data = JSON.stringify({ status });
            return new Promise((resolve, reject) => {
              const req = https.request({
                hostname: instance,
                path: '/api/v1/statuses',
                method: 'POST',
                headers: {
                  'Authorization': 'Bearer ' + token,
                  'Content-Type': 'application/json',
                  'Content-Length': data.length
                }
              }, (res) => {
                let body = '';
                res.on('data', chunk => body += chunk);
                res.on('end', () => {
                  const response = JSON.parse(body);
                  resolve(response.url);
                });
              });
              req.on('error', reject);
              req.write(data);
              req.end();
            });
          }

          async function postToBluesky(text, postUrl) {
            const handle = process.env.BLUESKY_HANDLE;
            const password = process.env.BLUESKY_APP_PASSWORD;
            const authData = JSON.stringify({ identifier: handle, password: password });
            const session = await new Promise((resolve, reject) => {
              const req = https.request({
                hostname: 'bsky.social',
                path: '/xrpc/com.atproto.server.createSession',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Content-Length': authData.length
                }
              }, (res) => {
                let body = '';
                res.on('data', chunk => body += chunk);
                res.on('end', () => resolve(JSON.parse(body)));
              });
              req.on('error', reject);
              req.write(authData);
              req.end();
            });
            const postText = text + '\n\n' + postUrl;
            const postData = JSON.stringify({
              repo: session.did,
              collection: 'app.bsky.feed.post',
              record: { text: postText, createdAt: new Date().toISOString() }
            });
            return new Promise((resolve, reject) => {
              const req = https.request({
                hostname: 'bsky.social',
                path: '/xrpc/com.atproto.repo.createRecord',
                method: 'POST',
                headers: {
                  'Authorization': 'Bearer ' + session.accessJwt,
                  'Content-Type': 'application/json',
                  'Content-Length': postData.length
                }
              }, (res) => {
                let body = '';
                res.on('data', chunk => body += chunk);
                res.on('end', () => {
                  const response = JSON.parse(body);
                  const bskyUrl = 'https://bsky.app/profile/' + handle + '/post/' + response.uri.split('/').pop();
                  resolve(bskyUrl);
                });
              });
              req.on('error', reject);
              req.write(postData);
              req.end();
            });
          }

          async function main() {
            const files = process.argv[2].split('\n').filter(f => f);
            for (const file of files) {
              console.log('Processing ' + file + '...');
              const post = parsePost(file);
              if (!post) {
                console.log('Could not parse ' + file);
                continue;
              }
              // Only syndicate if category is 'notes'
              if (post.frontmatter.category !== 'notes') {
                console.log('Skipping ' + file + ' (category is not notes)');
                continue;
              }
              const slug = file.match(/\d{4}-\d{2}-\d{2}-(.*?)\.md$/)[1];
              const date = file.match(/(\d{4})-(\d{2})-(\d{2})/);
              const postUrl = process.env.SITE_URL + '/notes/' + date[1] + '/' + date[2] + '/' + date[3] + '/' + slug;
              try {
                const mastodonUrl = await postToMastodon(post.content, postUrl);
                console.log('✓ Posted to Mastodon: ' + mastodonUrl);
                const blueskyUrl = await postToBluesky(post.content, postUrl);
                console.log('✓ Posted to Bluesky: ' + blueskyUrl);
              } catch (error) {
                console.error('✗ Error syndicating ' + file + ':', error.message);
              }
            }
          }
          main();
          SCRIPT_EOF
          
          node syndicate.js "${{ steps.new_notes.outputs.files }}"
